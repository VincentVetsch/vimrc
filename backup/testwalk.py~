#!/usr/bin/env python
# coding: utf-8

import os
import sys
import shelve
import threading
import hashlib

DATA_CACHE = os.path.expanduser('~/.pythonPathCache.shelve')
pythonPaths = {}


class PythonClasses(object):
    '''Class used to locate and represent all python classes on system'''
    # Class Variables
    # TODO -- Code all methods and implement the class
    DATA_CACHE = os.path.expanduser('~/.pythonPathCache.shelve')
    PythonClasses = {}
    PythonPaths = {}

    def __init__(self, dataDict):
        '''Initialize the class with data from DATA_CACHE

        Arguments:
            dataDict = a dictionary with python class data
        '''
        self.pythonPaths = dataDict

    def getFile(self):
        pass

    def setFile(self, fileName):
        pass

    def getAllFiles(self):
        pass

    def getFunctions(self, fileName):
        '''Get Functions from fileName, and returns a list of functions

        Arguments:
            fileName = a string that contains the path and the name of the fileName
        Returns:
            All Functions as a list
        '''
        return pythonPaths['paths'][fileName]['Functions']

    def getMethods(self, fileName, className):
        pass

    def getClasses(self, fileName):
        pass

    def __repr__(self):
        pass

    def __str__(self):
        pass

    def __iter__(self):
        pass

    def _findPrivateMethods(self):
        pass

    def _findUserMethods(self):
        pass


class ThreadingObject(threading.Thread):
    '''Class used to direct the gathering of class information'''
    def __init__(self, func, args, name=''):
        threading.Thread.__init__(self)
        self.name = name
        self.func = func
        self.args = args

    def run(self):
        self.func(*self.args)


# Begin Functions
def findFileinPyPath(selectName):
    '''Returns a specific python file from the class path'''
    for p in sys.path:
        tree = os.walk(p)
        for files in tree:
            for file in files[2]:
                if os.path.splitext(file)[1] == ".py" and os.path.splitext(file)[0] == selectName:
                    return str(files[0]) + "/" + file

    return None


def findClassesInFile(fileName):
    '''Returns classes and functions from the python file'''
    fileNameDict = {}  # FileNameDict - is used to store the functions, classes and methods of the file
    className = []  # Used to store the class and it's methods
    methodNames = []  # Used to store methods for the class under viewer
    methodDict = {}
    functionDict = {}
    functionNames = []  # Used to store module functions
    theClass = ''  # Used to store the current class
    beginClass = False  # Used to indicate that the current group of lines under test are within a class
    m = hashlib.md5()
    try:
        data = open(fileName, "r").readlines()
        # FIXME -- Why open the file twice make data read instead of readlines
        data1 = open(fileName, "rb").read(8192)
    except IOError:
        return None
    m.update(data1)
    md5sum = m.hexdigest()
    lineNumber = 0
    for line in data:
        lineNumber += 1
        # Reset beginClass and endClass when a new class occurs and stores
        # the dictionary for the next run
        if line.startswith('class') and beginClass == True:
            className.append({'LineNumber': lineNumber, theClass: methodNames})
            beginClass = False
            methodNames = []

        # Read the class until the next class
        if line.startswith('class') and beginClass == False:
            theClass = line.rstrip('\n').rstrip(' ') .rstrip(':')
            beginClass = True
        elif beginClass == True:
            # Read the methods of the class
            if line.find('def ') > 0:
                # TODO -- create a method list {lineNumber: methodNames}
                newMethod = line.lstrip(' ').rstrip('\n').rstrip(' ').rstrip(':')
                #print newMethod
                methodDict = {lineNumber: newMethod}
                methodNames.append(methodDict)

        # Read Functions in a non class
        elif line.startswith('def ') > 0:
            newFunc = line.lstrip(' ').rstrip('\n').rstrip(' ').rstrip(':')
            functionDict = {lineNumber: newFunc}
            functionNames.append(functionDict)

    className.append({'LineNumber': lineNumber, theClass: methodNames})
    # Weed out the blank junk lists and dictionarys
    if len(className) < 2 and functionNames != []:
        fileNameDict = {fileName: {'Functions': functionNames, 'Checksum': md5sum}}
    elif len(className) > 2 and functionNames == []:
        fileNameDict = {fileName: {'Classes': className, 'Checksum': md5sum}}
    elif len(className) > 2 and functionDict != []:
        fileNameDict = {fileName: {'Functions': functionNames, 'Classes': className, 'Checksum': md5sum}}
    else:
        return None
    return fileNameDict


def openCache():
    '''Returns Dictionary from DATA_CACHE'''
    # TODO -- Add more code to pull data out -- on second thought use the class
    # File size is roughly 20M the program takes roughly 7.7 seconds to process all of the data
    # After removing __init__.py from search the program takes roughly 6.5 seconds
    # After removing the print, the program takes 0.140 seconds
    # Program takes 1.7 seconds to pull one record and close the file
    # It seems to be operating in linear time most of the time is spent loading the file and gathering the keys
    try:
        pythonPaths = shelve.open(DATA_CACHE, "w", writeback=True)
    except:
        return None

    # print pythonPaths['paths']['/usr/lib/python2.7/dist-packages/wx-2.8-gtk2-unicode/wx/tools/XRCed/plugins/core.py']
    # print "os.py\n\tFunctions:"
    # for x in pythonPaths['paths']['/usr/lib/python2.7/os.py']['Functions']:
    #     print "\t" + x
    #allPythonFiles = pythonPaths['paths'].keys()
    #allPythonFiles.sort()
    #for x in allPythonFiles:
    #    print x
    return pythonPaths
    #pythonPaths.close()
    #print data
    #return data


def createCache(thePath):
    '''Creates the DATA_CACHE and returns the Dictionary'''
    # TODO -- Reduce file size and processing time
    # File size is roughly 20M, the program takes roughly 10 seconds to process all of the data
    # After removing __init__.py from search the program takes roughly 9.3 seconds
    # After clearing newData after use, the program takes roughly 9.2 seconds
    # After clearing up some extrainious information, File size is 9.6M and take 8.1 seconds to
    #  Gather information
    pythonClasses = {}

    tree = os.walk(thePath, followlinks=True)
    for files in tree:
        for file in files[2]:
            if os.path.splitext(file)[1] == ".py" and os.path.split(file)[1] != "__init__.py":
                fileKey = files[0] + "/" + file
                newData = findClassesInFile(fileKey)
                if newData == None:
                    pass
                elif type(newData) == dict:
                    pythonClasses[fileKey] = newData.values()
                fileKey = None
                newData = None
    return pythonClasses


if __name__ == "__main__":
    # TODO -- Include this in the thread
    # TODO -- Add thread to refresh the shelve after loading it to vim
    # numberOfThreads = 4
    i = 0
    threadList = []
    if os.path.exists(DATA_CACHE):
        pythonPaths = openCache()
        print pythonPaths
    else:
        #for i in numberOfThreads:   # create the threads
        for x in sys.path:      # create the data path for each thread created
            i += 1
            threadList.append(ThreadingObject(createCache, x, name=i))  # Create the thread object into threadlist
            # TODO -- Figure out how to sync the threads to pytonPaths
            # FIXME -- synchronize the threads
            pythonPaths[x] = createCache(x)  # This is where the data gets collected

        pythonData = shelve.open(DATA_CACHE, "n")
        pythonData['paths'] = pythonPaths
        pythonData.close()
    #pythonPaths.close()
