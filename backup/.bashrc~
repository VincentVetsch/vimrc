#!/bin/bash
######################################################################################################################################################
################################### MY BASHRC FILE ################################### MY BASHRC FILE ################################### MY BASHRC FILE
######################################################################################################################################################

##################################################
# 'About' section for 'The Ultimate Bashrc File' #
##################################################

function about() {
cat <<EOF
##################################################
# The Ultimate Bashrc File			 #
# .bashrc					 #
# Creator:		Inameiname		 #
# Version: 3.9			 		 #
# Last modified: 	12 October 2011		 #
# License:		GPLv3+			 #
#						 #
# Latest Changes:				 #
# 3.9 - 12/10/11 - Added more functions and 	 #
# aliases, including: about, cleanup,  		 #
# repository-update-check, title, paste, upper,  #
# lower, listhw, diffxml, vie, wgetall, cpo,  	 #
# isdef, quietly, cpus, codename, codename_ver,  #
# distro, jd, jda, upto, xpath, dups, 		 #
# comparenclean	relinux-copy, & remastersys-copy,#
# as well as add a relinux & remastersys alias	 #
# section, and updated extundelete aliases	 #
#			 			 #
# Descripton:					 #
# For those who love using the terminal, here is #
# a '.bashrc' file I created, mainly for those 	 #
# who've had issues with their own. Hopefully 	 #
# it'll benefit those of whom love aliases, 	 #
# functions, and such. Probably more than you  	 #
# need, so modify all you want. I've organized it#
# best I can to make it easier for using and 	 #
# modification. This is also for those many 	 #
# who've had a difficult time finding a good 	 #
# source for their own on the net, like it was 	 #
# for me.					 #
# Oh, and any modifications that others wish to  #
# share are always welcome. 			 #
#						 #
# Installation Instructions:			 #
# Just extract the tar file and put in your 	 #
# home directory. You may have to overwrite the  #
# current one, so be sure to backup whatever 	 #
# beforehand. FYI, the default text in the 	 #
# '.bashrc' is included in this version so if 	 #
# you haven't modified it at all, you should  	 #
# have nothing to worry about.			 #
# To refresh it, just type in the terminal:	 #
# source ~/.bashrc				 #
# ...or just close and open your terminal window.#
# 						 #
# License:					 #
# This program is free software; you can 	 #
# redistribute it and/or modify it under the 	 #
# terms of the GNU General Public License as 	 #
# published by the Free Software Foundation; 	 #
# either version 3 of the License, or (at your 	 #
# option) any later version.			 #
#						 #
# This program is distributed in the hope that it#
# will be useful, but WITHOUT ANY WARRANTY; 	 #
# without even the implied warranty of 		 #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR 	 #
# PURPOSE. See the GNU General Public License 	 #
# for more details.				 #
#						 #
# Credits:					 #
# Found through various sources (including 	 #
# several things by me). I credit when I can.	 #
# Commented-out stuff is what I personally do not#
# need, so use at your own risk.		 #
# Feel free to copy, share, tweak, eat, or	 #
# whatever. Just remember to give credit, as I 	 #
# have put a lot of work into this. Enjoy.	 #
##################################################
EOF
}

######################################################################################################################################################
#----- ORIGINAL CONTENT ------ ORIGINAL CONTENT ------ ORIGINAL CONTENT ------ ORIGINAL CONTENT ------ ORIGINAL CONTENT ------ ORIGINAL CONTENT ------
######################################################################################################################################################
shopt -s autocd checkjobs
# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# don't put duplicate lines in the history. See bash(1) for more options
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoredups:ignorespace

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
#force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.
if [ -f ~/.bash_functions ]; then
	. ~/.bash_functions
	myip
fi
if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi
# More functions.

# Database functions
if [ -f ~/.bash_data ]; then
	. ~/.bash_data
fi
# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    . /etc/bash_completion
fi

######################################################################################################################################################
#----- CUSTOM STARTS HERE ------ CUSTOM STARTS HERE ------ CUSTOM STARTS HERE ------ CUSTOM STARTS HERE ------ CUSTOM STARTS HERE ------ CUSTOM STARTS HERE
######################################################################################################################################################


######################################################################################################################################################
###### MISCELLANEOUS ###### MISCELLANEOUS ###### MISCELLANEOUS ###### MISCELLANEOUS ###### MISCELLANEOUS ###### MISCELLANEOUS ###### MISCELLANEOUS ######
######################################################################################################################################################


if [ "$PS1" ]; then	# if running interactively, then run till 'fi' at EOF:

# source ~/.bashlocalrc	# settings that vary per workstation
OS=$(uname)		# for resolving pesky os differing switches


######################################################################################################################################################
###### COMMAND PROMPT & CLI ###### COMMAND PROMPT & CLI ###### COMMAND PROMPT & CLI ###### COMMAND PROMPT & CLI ###### COMMAND PROMPT & CLI ######
######################################################################################################################################################

##################################################
# Prompt escapes				 #
##################################################

# Bash allows these prompt strings to be customized by inserting a
# number of backslash-escaped special characters that are
# decoded as follows:

#  \a         an ASCII bell character (07)
#  \d         the date in "Weekday Month Date" format (e.g., "Tue May 26")
#  \D{format} the format is passed to strftime(3) and the result
#             is inserted into the prompt string an empty format
#             results in a locale-specific time representation.
#             The braces are required
#  \e         an ASCII escape character (033)
#  \h         the hostname up to the first `.'
#  \H         the hostname
#  \j         the number of jobs currently managed by the shell
#  \l         the basename of the shell's terminal device name
#  \n         newline
#  \r         carriage return
#  \s         the name of the shell, the basename of $0 (the portion following
#             the final slash)
#  \t         the current time in 24-hour HH:MM:SS format
#  \T         the current time in 12-hour HH:MM:SS format
#  \@         the current time in 12-hour am/pm format
#  \A         the current time in 24-hour HH:MM format
#  \u         the username of the current user
#  \v         the version of bash (e.g., 2.00)
#  \V         the release of bash, version + patch level (e.g., 2.00.0)
#  \w         the current working directory, with $HOME abbreviated with a tilde
#  \W         the basename of the current working directory, with $HOME
#             abbreviated with a tilde
#  \!         the history number of this command
#  \#         the command number of this command
#  \$         if the effective UID is 0, a #, otherwise a $
#  \nnn       the character corresponding to the octal number nnn
#  \\         a backslash
#  \[         begin a sequence of non-printing characters, which could be used
#             to embed a terminal control sequence into the prompt
#  \]         end a sequence of non-printing characters
#
#  The command number and the history number are usually different:
#  the history number of a command is its position in the history
#  list, which may include commands restored from the history file
#  (see HISTORY below), while the command number is the position in
#  the sequence of commands executed during the current shell session.
#  After the string is decoded, it is expanded via parameter
#  expansion, command substitution, arithmetic expansion, and quote
#  removal, subject to the value of the promptvars shell option (see
#  the description of the shopt command under SHELL BUILTIN COMMANDS
#  below).



##################################################
# Color chart					 #
##################################################

txtblk='\e[0;30m' # Black - Regular
txtred='\e[0;31m' # Red
txtgrn='\e[0;32m' # Green
txtylw='\e[0;33m' # Yellow
txtblu='\e[0;34m' # Blue
txtpur='\e[0;35m' # Purple
txtcyn='\e[0;36m' # Cyan
txtwht='\e[0;37m' # White
bldblk='\e[1;30m' # Black - Bold
bldred='\e[1;31m' # Red
bldgrn='\e[1;32m' # Green
bldylw='\e[1;33m' # Yellow
bldblu='\e[1;34m' # Blue
bldpur='\e[1;35m' # Purple
bldcyn='\e[1;36m' # Cyan
bldwht='\e[1;37m' # White
unkblk='\e[4;30m' # Black - Underline
undred='\e[4;31m' # Red
undgrn='\e[4;32m' # Green
undylw='\e[4;33m' # Yellow
undblu='\e[4;34m' # Blue
undpur='\e[4;35m' # Purple
undcyn='\e[4;36m' # Cyan
undwht='\e[4;37m' # White
bakblk='\e[40m'   # Black - Background
bakred='\e[41m'   # Red
badgrn='\e[42m'   # Green
bakylw='\e[43m'   # Yellow
bakblu='\e[44m'   # Blue
bakpur='\e[45m'   # Purple
bakcyn='\e[46m'   # Cyan
bakwht='\e[47m'   # White
txtrst='\e[0m'    # Text Reset



##################################################
# This bashrc's current prompt		 	 #
##################################################

#PS1='\[\033]0;\w\007\]\[\e[35;1m\]\u\[\e[0m\]\[\e[32m\]@\h\[\e[34m\]\w \[\e[33m\]\$ \[\e[0m\]'	# purple, green, blue prompt w/default black & dir title



##################################################
# More command prompt choices (CHOOSE ONE, either#
# one of single lines below, or one of the	 #
# fancier ones farther below - just uncomment	 #
# one want and comment mine above)		 #
##################################################

PS1='\[\033[01;31m\]\u\[\033[01;36m\]@\[\033[01;32m\]\h\[\033[01;33m\]:\[\033[01;33m\]\w\n\[\033[01;31m\]\$ \[\e[0m\]'	# red, cyan, green, yellow with green output
# PS1="\[\033[01;32m\]\u@\h\[\033[01;34m\] \w \$\[\033[00m\] "					# green and blue prompt with pc name & default black output
# PS1="\[\033[0;31m\][\u] [ \w ] \[\033[0m\] \n # "						# red with default black output (2-tier)
# PS1="\[\033[0;33m\][\!]\`if [[ \$? = "0" ]]; then echo "\\[\\033[32m\\]"; else echo "\\[\\033[31m\\]"; fi\`[\u.\h: \`if [[ `pwd|wc -c|tr -d " "` > 18 ]]; then echo "\\W"; else echo "\\w"; fi\`]\$\[\033[0m\] "; echo -ne "\033]0;`hostname -s`:`pwd`\007"	# yellow and green with default black output
# PS1="\[\033[0;33m\][\!]\`if [[ \$? = "0" ]]; then echo "\\[\\033[32m\\]"; else echo "\\[\\033[31m\\]"; fi\`[\u.\h: \`if [[ `pwd|wc -c|tr -d " "` > 18 ]]; then echo "\\W"; else echo "\\w"; fi\`]\$\[\033[0m\] "; echo -ne "\033]0;`hostname -s`:`pwd`\007"	# yellow, green, w/black output w/color change upon bad command
# PS1="\[\033[0;34m\][\u] \[\033[0;0m\]\w \[\033[0m\]$ "					# blue username and default black output
# PS1="\[\033[0;34m\][\u] \[\033[0;31m\][ \w ] \[\033[0m\] \n >> "				# blue and red with default black output (2-tier)
# PS1="\[\033[0;34m\][\u] \[\033[0;33m\][ \t ] \[\033[0;31m\][ \w ] \[\033[0m\] \n >> "		# blue, yellow, red with default black output (2-tier)
# PS1='\[\033[1;30m\][\[\033[0;37m\]${PIPESTATUS}\[\033[1;30m\]:\[\033[0;37m\]${SHLVL}\[\033[1;30m\]:\[\033[0;37m\]\j\[\033[1;30m\]][\[\033[1;34m\]\u\[\033[0;34m\]@\[\033[1;34m\]\h\[\033[1;30m\]:\[\033[0;37m\]`tty | sed s/\\\\\/dev\\\\\/\//g`\[\033[1;30m\]]\[\033[0;37m\][\[\033[1;37m\]\W\[\033[0;37m\]]\[\033[1;30m\] \$\[\033[00m\] '									# grey and blue with default black output
# PS1="[\[\033[1;34m\]\u\[\033[0m\]@\h \W]\\$ "							# blue username with default colors (black)
# PS1="[\!] \033[1;36m[ \u@\h ]\033[1;32m\] [ \t ] [ \d ]\n\033[1;33m\[[ \w ] \033[00m\\n\[\e[30;1m\](\[\e[32;1m\]\$(/bin/ls -1 | /usr/bin/wc -l | /bin/sed 's: ::g') files, \$(/bin/ls -lah | /bin/grep -m 1 total | /bin/sed 's/total //')b\[\e[30;1m\]) \[\e[0m\] $: "	# black, cyan, green, yellow, default black output (2-tier)
# PS1="[\[\033[32m\]\w]\[\033[0m\]\n\[\033[1;36m\]\u\[\033[1;33m\]-> \[\033[0m\]"		# black, green, cyan, yellow, w/black output w/full path (2-tier)
# PS1="\[\033[34m\]   \u@\h `tty | sed 's/\/dev\///'` \t \d \[\033[35m\]\w/ \n\[\033[34m\] $\[\033[0m\] "	# cyan with green output
# PS1="\[\033[35m\]\t\[\033[m\]-\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ "	# purple, cyan, black, green, yellow, default black
# PS1="\[\033[35m\]\t\[\033[m\]-\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ "	# purple, cyan, black, green, yellow, w/black output
# PS1="\[\033[36m\]   \u@\h `tty | sed 's/\/dev\///'` \t \d \[\033[32m\]\w/ \n\[\033[36m\] $\[\033[0m\] "	# blue with purple output
# PS1=">\[\033[s\]\[\033[1;\$((COLUMNS-4))f\]\$(date +%H:%M)\[\033[u\]"				# trimmed up prompt with clock using default colors (black)
# PS1='C:${PWD//\//\\\}>'									# change prompt to MS-DOS one (joke)
# PS1='${debian_chroot:+($debian_chroot)}\[[ \033[01;31m\]\w\[\033[00m\]] '			# basic red with default black output
# PS1='\[\e[0;31m\]\u\[\e[m\] \[\e[1;34m\]\w\[\e[m\] \[\e[0;31m\]\$ \[\e[m\]\[\e[0;32m\]'	# red and blue prompt with green output
# PS1='\[\e[0;32m\]\u\[\e[m\] \[\e[1;34m\]\w\[\e[m\] \[\e[1;32m\]\$\[\e[m\] \[\e[1;37m\]'	# green and blue prompt with light grey output
# PS1='\[\e[0;32m\]\u\[\e[m\] \[\e[1;34m\]\w\[\e[m\] \[\e[1;32m\]\$\[\e[m\]'			# green and blue prompt with default black output
# PS1='\e[1;31;47m\u \e[1;32;47mon \h \e[1;35;47m\d \@\e[0;0m\n\e[1;31m[dir.= \w] \# > \e[0;0m'	# red, green, purple, red with default black output
# PS1='\[\e[1;31m\][\[\e[0;37m\]\u\[\e[1;31m\]@\[\e[0;37m\]\h \W\[\e[1;31m\]]\$\[\e[0m\] '	# red and grey with default black output
# PS1='\[\e[1;31m\][\u@\h \W]\$\[\e[0m\] '							# red color with default black output
# PS1='\[\e[1;32m\]\u@\H:\[\e[m\] \[\e[1;37m\]\w\[\e[m\]\n\[\e[1;33m\]hist:\! \[\e[0;33m\] \[\e[1;31m\]jobs:\j \$\[\e[m\] '	# green, yellow, red, grey and default black output (2-tier)
# PS1='\[\e[1;32m\]\u@\H:\[\e[m\] \[\e[1;37m\]\w\[\e[m\]\n\[\e[1;33m\]hist:\! \[\e[0;33m\] \[\e[1;31m\]jobs:\j \$\[\e[m\] '	# green, yellow, red, w/black output (2-tier) w/background job count
# PS1='\[\e[1;32m\][\u@\h \W]\$\[\e[0m\] '							# green color with default black output
# PS1='\e[1;33;47m\u \e[1;32;47mon \h \e[1;35;47m\d \@\e[0;0m\n\e[1;34m[dir.= \w] \# > \e[0;0m'	# yellow, green, purple, cyan with default black output
# PS1="\[\e[1;33m\] > \[\033[0m\]"								# basic yellow with default black output & nothing else
# PS1='\[\e[1m\]\h:\w\$\[\e[0m\] '								# black-bold with default colors (black)
# PS1="\[\e]2;\u@\H \w\a\e[30;1m\]>\[\e[0m\] "							# trimmed up prompt w/black arrow & title is current dir.
# PS1="\[\e[30;1m\]\w> \[\e[0m\]"								# trimmed up prompt with just black arrow and default colors
# PS1="\[\e[36;1m\]\u@\[\e[32;1m\]\H> \[\e[0m\]"						# cyan and green prompt with default black output
# PS1="\[\e[37;1m\]-{\[\e[34;1m\]\u@\h\[\e[37;1m\]}-\n\[\e[37;1m\](\[\e[34;1m\]\w: \$(/bin/ls -1 | /usr/bin/wc -l | /bin/sed 's: ::g') files, \$(/bin/ls -lah | /bin/grep -m 1 total | /bin/sed 's/total //')b\[\e[37;1m\])\n--> \[\e[0m\]"		# grey and cyan w/black output (2-tier) w/dir size
# PS1='\[\e[41m\]\[\e[1;37m\] \u \[\e[47m\]\[\e[1;30m\] \W \[\e[0m\]\[\e[1;37m\]\[\e[42m\] # \[\033[0m\] '	# red, grey, green boxed with default black
# PS1='\[\e[45m\]\[\e[1;37m\] \u@\h \[\e[47m\]\[\e[1;30m\] \W \[\e[0m\]\[\e[1;37m\]\[\e[42m\] > \[\033[0m\] '	# purple, grey, green boxed with default black
# PS1='\[\e[m\n\e[0;33m\][$$:$PPID \j:\!\[\e[0;33m\]]\[\e[0;36m\] \T \d \[\e[1;34m\][\[\e[1;34m\]\u@\H\[\e[1;31m\]:\[\e[0;37m\]${SSH_TTY} \[\e[0;32m\]+${SHLVL}\[\e[1;30m\]] \[\e[1;31m\]\w\[\e[0;30m\] \n($SHLVL:\!)\$ '				# yellow, cyan, red, blue, white, green, black, red w/ default black output
# PS1="\`if [ \$? = 0 ]; then echo \[\e[33m\]^_^\[\e[0m\]; else echo \[\e[31m\]O_O\[\e[0m\]; fi\`[\u@\h:\w]\\$ "	# all black with happy face (yellow/red) upon successful completion
# PS1="\`if [ \$? = 0 ]; then echo \[\e[33m\]^_^\[\e[0m\]; else echo \[\e[31m\]O_O\[\e[0m\]; fi\`[\u@\h:\w]\\$ "	# basic prompt but with yellow smiley
# PS1="\n\[\033[32;1m\]It's \t\[\033[33;1m\] Currently browsing \[\033[1;36m\]\w \[\033[33;1m\]directory\n\[\033[34;1m\]\`if [ \$? = 0 ]; then echo \[\e[37m\]Last Command Was Successfully Executed \[\e[32m\]^_^\[\e[0m\]; else echo \[\e[37m\]Smeggin Hell !!! Last Command Was Unknown \[\e[32m\]O_O\[\e[0m\]; fi\` \n\[\033[31m\]What is thy bidding, my master? \n\n\[\033[34;1m\]"				# green, yellow, grey, green, red, w/cyan output (3-tier) Star Wars version
# PS1="\n\[\033[35m\]\$(/bin/date)\n\[\033[32m\]\w\n\[\033[1;31m\]\u@\h: \[\033[1;34m\]\$(/usr/bin/tty | /bin/sed -e 's:/dev/::'): \[\033[1;36m\]\$(/bin/ls -1 | /usr/bin/wc -l | /bin/sed 's: ::g') files \[\033[1;33m\]\$(/bin/ls -lah | /bin/grep -m 1 total | /bin/sed 's/total //')b\[\033[0m\] -> \[\033[0m\]"	- purple, green, blue, cyan, yellow, with default black output (3-tier)
# PS1="\n\[\033[35m\]\$(/bin/date)\n\[\033[32m\]\w\n\[\033[1;31m\]\u@\h: \[\033[1;34m\]\$(/usr/bin/tty | /bin/sed -e 's:/dev/::'): \[\033[1;36m\]\$(/bin/ls -1 | /usr/bin/wc -l | /bin/sed 's: ::g') files \[\033[1;33m\]\$(/bin/ls -lah | /bin/grep -m 1 total | /bin/sed 's/total //')b\[\033[0m\] -> \[\033[0m\]"												# purple, red, blue, cyan, yellow, w/white output (3-tier)
# PS1="\n\[$bldgrn\][\[$txtrst\]\w\[$bldgrn\]]\[$bldwht\]\n\[$bldwht\][\[$txtrst\]\t\[$bldwht\]]\[$bldylw\]$ \[$txtrst\]"	# green, black, grey, yellow with default black output (3-tier)
# PS1="\n#--[\[\e[1;36m\]\u@\h\[\e[m\]]-[\[\e[1;34m\]\w\[\e[m\]]-[\$(date +%k:%M)]-->\n"	# black, cyan, blue, black, w/black output (2-tier)
# PS1="\n\[\e[30;1m\]\[\016\]l\[\017\](\[\e[34;1m\]\u@\h\[\e[30;1m\])-(\[\e[34;1m\]\j\[\e[30;1m\])-(\[\e[34;1m\]\@ \d\[\e[30;1m\])->\[\e[30;1m\]\n\[\016\]m\[\017\]-(\[\[\e[32;1m\]\w\[\e[30;1m\])-(\[\e[32;1m\]\$(/bin/ls -1 | /usr/bin/wc -l | /bin/sed 's: ::g') files, \$(/bin/ls -lah | /bin/grep -m 1 total | /bin/sed 's/total //')b\[\e[30;1m\])--> \[\e[0m\]"				# grey, cyan, green, w/black output (2-tier) w/ dir. info
# PS1="\n\[\e[30;1m\]?(\[\e[34;1m\]\u@\h\[\e[30;1m\])-(\[\e[34;1m\]\j\[\e[30;1m\])-(\[\e[34;1m\]\@ \d\[\e[30;1m\])->\[\e[30;1m\]\n??(\[\e[32;1m\]\w\[\e[30;1m\])-(\[\e[32;1m\]$(/bin/ls -1 | /usr/bin/wc -l | /bin/sed 's: ::g') files, $(/bin/ls -lah | /bin/grep -m 1 total | /bin/sed 's/total //')b\[\e[30;1m\])--> \[\e[0m\]"	# black, cyan, green w/black output (2-tier)
# PS1="\n\[\e[32;1m\](\[\e[37;1m\]\u\[\e[32;1m\])-(\[\e[37;1m\]jobs:\j\[\e[32;1m\])-(\[\e[37;1m\]\w\[\e[32;1m\])\n(\[\[\e[37;1m\]! \!\[\e[32;1m\])-> \[\e[0m\]"	# grey and green with default black output (3-tier)
# PS1="\n\[\e[m\][\[\033[01;32m\]\w\[\e[m\]] [\t] \n\[\033[01;33m\]$ \[\033[00m\]"		# green, black, yellow, with default black output (3-tier)
# PS1="\t \u@\h\$ "										# simple prompt with time (black)
# PS1="\t \u@\h `tty | sed 's/\/dev\///'` \w \$ "						# longer prompt with time (black)
# PS1="\u@\h\$ "										# simple default prompt (black)
# PS1="\u@\h `tty | sed 's/\/dev\///'` \w \$ "							# longer prompt with brief info (black)
# PS1='[\u@\h \W]\$ '										# default colors (black)
# PS1="\u@\h [\w] \$ "										# simple prompt with directory (black)
# PS1="\u `tty | sed 's/\/dev\///'` [\W] \$ "							# prompt with brief info (black)



##################################################
# Jsnx's prompt of power (disabled by a single 	 #
# "#")			 			 #
##################################################

## I used to have the prompt set up as a bunch of functions; but that
## didn't work very well with sh. Now, I have mastered the various
## levels of evaluation and quoting of the shell and can confidently
## write hideous macros!
# DARK="\[\e[01;34m\]"
# NORM="\[\e[01;32m\]"
# FADE="\[\e[01;30m\]"
# REST="\[\e[00;00m\]"
# HIGH="\[\e[01;33m\]"
# dir="pwd -P | awk '{ printf \"%-65.65s\", \$1 }'"
# sub="sed -r 's/^/$NORM/ ; s|/|$FADE&$NORM|g ; s/:/$DARK&$NORM/g'"
# t="date +%H:%M"
# hist="history 1 | xargs echo '' | awk '{ printf \"%03.3d\", \$1 + 1 }'"
# warn="[ $USER = root ] && echo -n '$HIGH' || echo -n '$FADE'"
# bang="echo -ne '\x21'"  ## this gives me a single '!' in bash and sh
# prompt=" $DARK: \`$dir | $sub\` \`$warn;$bang;\`$NORM\`$hist\` \`$t | $sub\`
# $DARK:\`$warn\`; $REST"
# prepend=''
# if [ "${TERM}" = "xterm" ]
# then
#  my_tty=`tty | awk -F/ '{ print $3 $4}'`
#  xterm_title="\[\e]0;${my_tty} \u@\H\007\]"
#  prepend="${xterm_title}"
# fi
## export  PROMPT_COMMAND="export PS1=\"${prepend}${prompt}\""
# export  PS1="${prepend}${prompt}"
# export  PS2='  '



##################################################
# Nate Mitchell's (Kasyx's) Bash Prompt (red with#
# green dashes and black output) (disabled by a	 #
# single "#")		 			 #
##################################################

# function prompt() {
# Black="\e[30m"
# Red="\e[31m"
# Green="\e[32m"
# LightGreen="\e[32;1m"
# Blue="\e[34m"
# LightBlue="\e[34;1m"
# NC="\e[0m" # No Color
# PS1="\[$LightGreen\033(0\154\033(B\][\[\033(0\161\161\033(B$Green\][\[$Red\]\u@\h\[$Green\]]\[\033(0\161\033(B\][\[$Red\]\w\[$Green\]]\[\033(0\161\033(B\][\[$Red\]\!\[$Green\]]\[\033(0\161\161\033(B\]]\n\[$LightGreen\033(0\155\161\033(B$Green\][\[$Red\]\#\[$Green\]]\[\033(0\161\033(B\][\[$Red\]\$\[$Green\]]\[\033(0\161\161\033(B\][\[$NC\]"
# PS2="> "
# }
# prompt



##################################################
# Wolfman's prompt (disabled by a single "#")	 #
##################################################

## Fancy PWD display function
## The home directory (HOME) is replaced with a ~
## The last pwdmaxlen characters of the PWD are displayed
## Leading partial directory names are striped off
## /home/me/stuff          -> ~/stuff               if USER=me
## /usr/share/big_dir_name -> ../share/big_dir_name if pwdmaxlen=20
# function bash_prompt_command() {
#    # How many characters of the $PWD should be kept
#    local pwdmaxlen=25
#    # Indicate that there has been dir truncation
#    local trunc_symbol=".."
#    local dir=${PWD##*/}
#    pwdmaxlen=$(( ( pwdmaxlen < ${#dir} ) ? ${#dir} : pwdmaxlen ))
#    NEW_PWD=${PWD/#$HOME/\~}
#    local pwdoffset=$(( ${#NEW_PWD} - pwdmaxlen ))
#    if [ ${pwdoffset} -gt "0" ]
#    then
#        NEW_PWD=${NEW_PWD:$pwdoffset:$pwdmaxlen}
#        NEW_PWD=${trunc_symbol}/${NEW_PWD#*/}
#    fi
# }
# function bash_prompt() {
#    case $TERM in
#     xterm*|rxvt*)
#         local TITLEBAR='\[\033]0;\u:${NEW_PWD}\007\]'
#          ;;
#     *)
#         local TITLEBAR=""
#          ;;
#    esac
#    local NONE="\[\033[0m\]"    # unsets color to term's fg color
#    # regular colors
#    local K="\[\033[0;30m\]"    # black
#    local R="\[\033[0;31m\]"    # red
#    local G="\[\033[0;32m\]"    # green
#    local Y="\[\033[0;33m\]"    # yellow
#    local B="\[\033[0;34m\]"    # blue
#    local M="\[\033[0;35m\]"    # magenta
#    local C="\[\033[0;36m\]"    # cyan
#    local W="\[\033[0;37m\]"    # white
#    # emphasized (bolded) colors
#    local EMK="\[\033[1;30m\]"
#    local EMR="\[\033[1;31m\]"
#    local EMG="\[\033[1;32m\]"
#    local EMY="\[\033[1;33m\]"
#    local EMB="\[\033[1;34m\]"
#    local EMM="\[\033[1;35m\]"
#    local EMC="\[\033[1;36m\]"
#    local EMW="\[\033[1;37m\]"
#    # background colors
#    local BGK="\[\033[40m\]"
#    local BGR="\[\033[41m\]"
#    local BGG="\[\033[42m\]"
#    local BGY="\[\033[43m\]"
#    local BGB="\[\033[44m\]"
#    local BGM="\[\033[45m\]"
#    local BGC="\[\033[46m\]"
#    local BGW="\[\033[47m\]"
#    local UC=$W                 # user's color
#    [ $UID -eq "0" ] && UC=$R   # root's color
##    PS1="$TITLEBAR ${EMK}[${UC}\u${EMK}@${UC}\h ${EMB}\${NEW_PWD}${EMK}]${UC}\\$ ${NONE}"
#    # without colors: PS1="[\u@\h \${NEW_PWD}]\\$ "
#    # extra backslash in front of \$ to make bash colorize the prompt
# }
# PROMPT_COMMAND=bash_prompt_command
# bash_prompt
# unset bash_prompt



##################################################
# Emmanuel Rouat's shell prompt (fancy all	 #
# black with info)				 #
##################################################

# if [[ "${DISPLAY%%:0*}" != "" ]]; then
#    HILIT=${red}   # remote machine: prompt will be partly red
# else
#    HILIT=${cyan}  # local machine: prompt will be partly cyan
# fi
##   --> Replace instances of \W with \w in prompt functions below
## + --> to get display of full path name.
# function fastprompt()
# {
#    unset PROMPT_COMMAND
#    case $TERM in
#        *term | rxvt )
#            PS1="${HILIT}[\h]$NC \W > \[\033]0;\${TERM} [\u@\h] \w\007\]" ;;
#        linux )
#            PS1="${HILIT}[\h]$NC \W > " ;;
#        *)
#            PS1="[\h] \W > " ;;
#    esac
# }
# function _powerprompt()
# {
#    LOAD=$(uptime|sed -e "s/.*: \([^,]*\).*/\1/" -e "s/ //g")
# }
#
# function powerprompt()
# {
#    PROMPT_COMMAND=_powerprompt
#    case $TERM in
#        *term | rxvt  )
#            PS1="${HILIT}[\A - \$LOAD]$NC\n[\u@\h \#] \W > \
#                 \[\033]0;\${TERM} [\u@\h] \w\007\]" ;;
#        linux )
#            PS1="${HILIT}[\A - \$LOAD]$NC\n[\u@\h \#] \W > " ;;
#        * )
#            PS1="[\A - \$LOAD]\n[\u@\h \#] \W > " ;;
#    esac
# }
# powerprompt     # This is the default prompt -- might be slow.
#                # If too slow, use fastprompt instead. ...



##################################################
# Xterm windowdressing (cyan and black with	 #
# grey output info prompt( (disabled by a	 #
# single '#')					 #
##################################################

# function elite()
#  {
#  local GRAY="\[\033[1;30m\]"
#  local LIGHT_GRAY="\[\033[0;37m\]"
#  local CYAN="\[\033[0;36m\]"
#  local LIGHT_CYAN="\[\033[1;36m\]"
#  case $TERM in
#      xterm*)
#          local TITLEBAR='\[\033]0;\u@\h:\w\007\]'
#          ;;
#      *)
#          local TITLEBAR=""
#          ;;
#  esac
#  local GRAD1=$(tty|cut -d/ -f3)
#  PS1="$TITLEBAR\
#  $GRAY-$CYAN-$LIGHT_CYAN(\
#  $CYAN\u$GRAY@$CYAN\h\
#  $LIGHT_CYAN)$CYAN-$LIGHT_CYAN(\
#  $CYAN\#$GRAY/$CYAN$GRAD1\
#  $LIGHT_CYAN)$CYAN-$LIGHT_CYAN(\
#  $CYAN\$(date +%H%M)$GRAY/$CYAN\$(date +%d-%b-%y)\
#  $LIGHT_CYAN)$CYAN-$GRAY-\
#  $LIGHT_GRAY\n\
#  $GRAY-$CYAN-$LIGHT_CYAN(\
#  $CYAN\$$GRAY:$CYAN\w\
#  $LIGHT_CYAN)$CYAN-$GRAY-$LIGHT_GRAY "
#  PS2="$LIGHT_CYAN-$CYAN-$GRAY-$LIGHT_GRAY "
#  }
# PROMPT_COMMAND=elite



##################################################
# Another prompt =				 #
# (PS1="\[\e]2;\u@\H \w\a\e[30;1m\]>\[\e[0m\]	 #
# " but fixed for various systems - simple	 #
# prompt that shows currently directory in	 #
# title)					 #
##################################################

# if [ "$TERM" = "linux" ]
# then
#	# we're on the system console or maybe telnetting in
#	export PS1="\[\e[32;1m\]\u@\H > \[\e[0m\]"
# else
#	# we're not on the console, assume an xterm
#	export PS1="\[\e]2;\u@\H \w\a\e[32;1m\]>\[\e[0m\] "
# fi



##################################################
# Yet another prompt (simple black prompt with	 #
# the word 'bash$' only)			 #
##################################################

## Check if running in an xterm and give a more suitable prompt
## (two alternative blocks given below)
## mesg y allows talk(1) requests, here only if not an xterm
## Gives informative prompt, puts user,host,path in xterm title
## Comment or uncomment all of the following lines ('case' to 'esac')
# case $TERM in
#     xterm*)
#        PS1="\[\033]0;\u@\h: \w\007\]bash\$ "
#       ;;
#  *)
#      PS1="\t \u@\h `tty | sed 's/\/dev\///'`\$ "
#       mesg y
#        ;;
# esac



##################################################
# Still another prompt (cyan and red with	 #
# green output info prompt) (disabled by a	 #
# single '#')					 #
##################################################

### Colourful prompts
### Comment or uncomment all of the following lines ('case' to 'esac')
## case $TERM in
##      xterm*)
##          TERM=xterm-color; export TERM
##          PS1="\[\033[36m\]   \u@my_computer `tty | sed 's/\/dev\///'` \t \d \[\033[35m\]\w/ \n\[\033[36m\] $\[\033[0m\] "
##          ;;
##      *)
#          PS1="`setterm -bold on` \[\033[36m\] \u@my_computer `tty | sed 's/\/dev\///'` \t \d \[\033[1;31m\]\w/ \n\[\033[36m\]! \[\033[1;32m\] `setterm -#bold off`"
#    # this adds a bg color; comment out the above
##      PS1="\[\033[35m\]   \u@my_computer `tty | sed 's/\/dev\///'` \t \d \[\033[32m\]\w/ \n\[\033[36m\] $\[\033[44;1;36m\] `setterm -bold on` "
##          mesg y
##          ;;
## esac



##################################################
# More PROMPT_COMMANDS				 #
##################################################

###### Annoying PROMPT_COMMAND animation
# PROMPT_COMMAND='seq $COLUMNS | xargs -IX printf "%Xs\r" @'



###### Saves terminal commands in history file in real time (for use with 'shopt -s histappend')
PROMPT_COMMAND="history -a;$PROMPT_COMMAND"	# use with 'shopt -s histappend';save terminal commands in history file in real time



###### Share history between using multiple commands (press enter before get history from other bash shells)
# PROMPT_COMMAND='history -a && history -n'



###### Shows date
# PROMPT_COMMAND='date +%k:%m:%S'



###### Shows memory, load average, and history
# PROMPT_COMMAND='history -a;echo -en "\033[m\033[38;5;2m"$(( `sed -nu "s/MemFree:[\t ]\+\([0-9]\+\) kB/\1/p" /proc/meminfo`/1024))"\033[38;5;22m/"$((`sed -nu "s/MemTotal:[\t ]\+\([0-9]\+\) kB/\1/Ip" /proc/meminfo`/1024 ))MB"\t\033[m\033[38;5;55m$(< /proc/loadavg)\033[m"'



###### Shows the return value of the last executed command (using smileys as to whether it was successful or not)
# PROMPT_COMMAND='RET=$?; if [[ $RET -eq 0 ]]; then echo -ne "\033[0;32m$RET\033[0m ;)"; else echo -ne "\033[0;31m$RET\033[0m ;("; fi; echo -n " "'



##################################################
##################################################
##################################################


######################################################################################################################################################
###### BASH SETTINGS ###### BASH SETTINGS ###### BASH SETTINGS ###### BASH SETTINGS ###### BASH SETTINGS ###### BASH SETTINGS ###### BASH SETTINGS ######
######################################################################################################################################################


# autoload -U compinit				# use to enable famous zsh tab-completion system
# compinit					# use to enable famous zsh tab-completion system
export BLOCKSIZE=K				# set blocksize size
export BROWSER='firefox'			# set default browser
# export BROWSER='opera'			# set default browser
# export BROWSER=$(find_alternatives chromium-browser google-chrome opera firefox firefox-bin iceweasel konqueror w3m lynx)	# uses function 'find_alternatives'
export CDDIR="$HOME"			# for use with the function 'cd' and the alias 'cdd'
# export CDPATH=.:~:~/src:/etc
# export CDPATH=.:~:~/Dropbox 			# if you use dropbox from the command line often
# export DISPLAY=:79
# export EDITOR='gedit'				# use default text editor
# export EDITOR="gedit -w --resume" Typing 'fc'	# open last command for editing in gedit, then execute on save
#export EDITOR='geany'				# use default text editor
export EDITOR='kate'
# export ftp_proxy=${MY_PROXY}
# export GPG_TTY='tty'				# gpg-agent says it needs this
# export GREP_OPTIONS='-D skip --binary-files=without-match --ignore-case'		# most commonly used grep options
export HISTCONTROL=ignoreboth:erasedups		# for 'ignoreboth': ignore duplicates and /^\s/
# export HISTCONTROL=ignoreboth			# ignore spaced commands and prevents storing of duplicate commands (ie, ignoredups & ignorespace)
# export HISTCONTROL=ignoredups			# don't put duplicate lines in the history. See bash(1) for more options
# export HISTCONTROL=ignorespace		# will make sure that bash don’t store any command beginning with the space character
# export HISTFILE=/dev/null			# disable history for current shell session
# export HISTFILE='$HOME/.history'		# set history file location
# export HISTFILESIZE=10000			# increase or decrease the size of the history to '10,000'
# export HISTFILESIZE=${HISTSIZE}		# bash will remember 'N' commands
export HISTIGNORE='&:bg:fg:ll:h'
# export HISTIGNORE='${HISTIGNORE:+$HISTIGNORE:}la:ll:lah:lat:;a:-:fg:bg:j:sync:esu:rma:rmp:fol:pfol'
# export HISTIGNORE="&:ls:[bf]g:exit"		# duplicate entries in bash history, as well as ls, bg, fg & exit, making for cleaner bash history
# export HISTIGNORE="&:ls:ll:la:l.:pwd:exit:clear"
# export HISTIGNORE='pwd:cd:ls:ls -l:'		# ignore commands given
export HISTSIZE=10000				# increase or decrease the size of the history to '10,000'
# export HISTTIMEFORMAT='| %d/%m/%y %T | '	# make 'History' Show The Date For Each Command
# export HISTTIMEFORMAT='%F %T '		# adds date and time to history
export HISTTIMEFORMAT='%H:%M > '
# export HISTTIMEFORMAT='%s' 			# the beloved Second of Our Linux
# export HISTTIMEFORMAT='%Y-%b-%d::%Hh:%Mm:%Ss '
export HISTTIMEFORMAT='%Y-%m-%d_%H:%M:%S_%a  '	# makes history display in YYYY-MM-DD_HH:MM:SS_3CharWeekdaySpaceSpace format
export HOSTFILE=$HOME/.hosts    		# put list of remote hosts in ~/.hosts ...
# export http_proxy=${MY_PROXY}			# proxy setting
# export https_proxy=${MY_PROXY}		# proxy setting
# export IGNOREEOF=1				# prevent CTRL-D from immediately logging out
# export INPUTRC=/etc/inputrc			# it's possible that this will make bash find my delete key (and everything else)((but i don't think it did))
# export INPUTRC=$HOME/.inputrc			# type in ‘whatever’ and press ‘Page Up’ key and bash automatically fetches last command that starts with whatever and completes the command for you (requires '$HOME/.inputrc' with these lines: #Page up/page down && "\e[5~": history-search-backward && "\e[6~": history-search-forward)
# export LC_COLLATE="en_CA.utf8"		# change sorting methods [a-Z] instead of [A-Z]
export LESSCHARSET='latin1'
export LESS='-i -N -w  -z-4 -g -e -M -X -F -R -P%t?f%f \'
# export LESSOPEN="|lesspipe.sh %s"; export LESSOPEN
export LESSOPEN='|/usr/bin/lesspipe.sh %s 2>&-'	# use this if lesspipe.sh exists
# export LESS="-QR"				# tell less not to beep and also display colours
# export LESS='-R'
# export LESS_TERMCAP_mb=$'\E[01;31m'      	# less colors for Man pages # begin blinking
# export LESS_TERMCAP_md=$'\E[01;38;5;74m'  	# less colors for Man pages # begin bold
# export LESS_TERMCAP_me=$'\E[0m'           	# less colors for Man pages # end mode
# export LESS_TERMCAP_se=$'\E[0m'           	# less colors for Man pages # end standout-mode
# export LESS_TERMCAP_so=$'\E[38;5;246m'    	# less colors for Man pages # begin standout-mode - info box
# export LESS_TERMCAP_ue=$'\E[0m'           	# less colors for Man pages # end underline
# export LESS_TERMCAP_us=$'\E[04;38;5;146m' 	# less colors for Man pages # begin underline
# export LIBGL_DRIVERS_PATH=/usr/lib/xorg/modules/dri					# gallium
# export MY_PROXY='http://YOUR_USERNAME:YOUR_PASSWORD@PROXY_IP:PROXY_PORT/'
# export OOO_FORCE_DESKTOP=gnome   		# openoffice preferences
# export OPERA_KEEP_BLOCKED_PLUGIN=1		# this is the special sauce to enhance flash (on opera's) performance
# export OPERAPLUGINWRAPPER_PRIORITY=0		# this is the special sauce to enhance flash (on opera's) performance
export PAGER='less -e'
# export PATH=$PATH:$HOME/scripts
# export PILOTRATE=57600			# make pilot-xfer go faster than 9600
export TERM='xterm'
export TIMEFORMAT=$'\nreal %3R\tuser %3U\tsys %3S\tpcpu %P\n'
#export TMOUT=600				# auto logout after n seconds of inactivity
# export USER_CLIENT=deluge
# export USER_DPRT=22218
# export USER_OPRT=47426
# export USER_VPRT=79
# export USER_WPRT=30818
export VIDEO_FORMAT=NTSC			# for use with creating compatible DVDs ('dvdauthor -x dvdauthor.xml' will fail if this not here)
# export VIDEO_FORMAT=PAL			# for use with creating compatible DVDs ('dvdauthor -x dvdauthor.xml' will fail if this not here)
export VISUAL='vi'
# export wpsetters=feh
# ${file%\.[^.]*}				# to remove filename extensions in bash
# fortune -a					# fortunes at each new shell
# mesg n              				#
set -b						# causes output from background processes to be output right away, not on wait for next primary prompt
# set bell-style visible			# I hate noise
# set completion-ignore-case on 		# complete things that have been typed in the wrong case
# set -o ignoreeof				# can't c-d out of shell
# set -o noclobber				# disallow > to work on files that already exist (prevents catting over file)
set -o notify					# notify when jobs running in background terminate
# set -o nounset				# attempt to use undefined variable outputs error message and forces exit (messes up completion if enabled)
# set +o nounset          			# otherwise some completions will fail
# setopt autopushd pushdminus pushdsilent pushdtohome
# setopt correct
# setopt extendedglob
# setopt hist_ignore_space    			# prepend ' ' to not be saved
# setopt hist_verify          			# verify when using !
# setopt nocheckjobs          			# don't complain about background jobs on e
# setopt no_clobber           			# don't overwrite files when redirect
# setopt nohup               			# don't kill bg jobs when tty quits
# setopt printexitvalue       			# print exit value from jobs
# setopt share_history
# set -o xtrace					# useful for debuging
# setterm -blength 0				# set the bell duration in milliseconds (silence the beeps)
# set visible-stats on 				# when listing possible file completions, put / after directory names and * after programs
shopt -s cdable_vars				# set the bash option so that no '$' is required (disallow write access to terminal)
shopt -s cdspell				# this will correct minor spelling errors in a cd command
shopt -s checkhash
shopt -s checkwinsize				# update windows size on command
shopt -s cmdhist          			# save multi-line commands in history as single line
shopt -s dotglob				# files beginning with . to be returned in the results of path-name expansion
#shopt -s expand aliases			# expand aliases
shopt -s extglob				# necessary for bash completion (programmable completion)
shopt -s globstar				# enables the ** globbing operator
# shopt -s histappend				# bash history is only saved when close terminal, not after each command and this fixes it
shopt -s histappend histreedit histverify
# shopt -s histreedit
# shopt -s histverify
# shopt -s hostcomplete     			# attempt hostname expansion when @ is at the beginning of a word
# shopt -s huponexit
shopt -s mailwarn				# keep an eye on the mail file (access time)
# shopt -s nocaseglob cdspell histappend
shopt -s nocaseglob       			# pathname expansion will be treated as case-insensitive (auto-corrects the case)
shopt -s no_empty_cmd_completion		# no empty completion (bash>=2.04 only)
# shopt -s nullglob dotglob
shopt -s sourcepath
# shopt -u cmdhist				# do not treat multiple line commands as a single entry
# shopt -u force_fignore			# expand to complete an ignored word, if no other words match.
# shopt -u mailwarn
# shopt -u sourcepath
# stty -ixon					# disable XON/XOFF flow control (^s/^q)
stty start undef
stty stop undef
# stty stop ''					# use C-s to search forward through history (do not block output)
# ulimit -c unlimited				# let me have core dumps
ulimit -S -c 0          			# (core file size) don't want any coredumps
# ulimit -S -f 1024   				# open files
# ulimit -S -s 8192  				# stack size
# ulimit -S -u 256    				# max user processes
# umask 007    					# all files created 660, dirs 770
# umask 022					# makes new files have permissions: rwxr-xr-x
# umask 077           				# after everything is installed, uncomment this and the mkdir alias below ((base 8) 777 & ~077 = 700 = u=rwx,g=,o=)
# unset HISTFILESIZE				# infinite History
# unset HISTSIZE				# infinite History
unset MAILCHECK        				# don't want my shell to warn me of incoming mail
# unsetopt bgnice            			# don't nice bg command

if [ -d $HOME/Maildir/ ]; then
    export MAIL=$HOME/Maildir/
    export MAILPATH=$HOME/Maildir/
    export MAILDIR=$HOME/Maildir/
elif [ -f /var/mail/$USER ]; then
    export MAIL="/var/mail/$USER"
fi

if [ "$TERM" = "screen" ]; then
    export TERM=$TERMINAL
fi

# if [ "$OS" = "Linux" ]; then
#     source ~/.lscolorsrc
# elif [ "$OS" = "Darwin" ]; then
#     export LSCOLORS='gxfxcxdxbxegedabagacad'
# fi

function get_xserver()
{
    case $TERM in
       xterm )
            XSERVER=$(who am i | awk '{print $NF}' | tr -d ')''(' )
            # Ane-Pieter Wieringa suggests the following alternative:
            # I_AM=$(who am i)
            # SERVER=${I_AM#*(}
            # SERVER=${SERVER%*)}
            XSERVER=${XSERVER%%:*}
            ;;
        aterm | rxvt)
        # Find some code that works here. ...
            ;;
    esac
}
if [ -z ${DISPLAY:=""} ]; then
    get_xserver
    if [[ -z ${XSERVER}  || ${XSERVER} == $(hostname) || \
      ${XSERVER} == "unix" ]]; then
        DISPLAY=":0.0"          # Display on local host.
    else
        DISPLAY=${XSERVER}:0.0  # Display on remote host.
    fi
fi
export DISPLAY

# if [ -f ~/.bash_exports ]; then . ~/.bash_exports ; fi
# if [ -f ~/.bash_functions ]; then . ~/.bash_functions ; fi
# if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases ; fi
# if [ -f ~/.bash_completion ]; then . ~/.bash_completion ; fi
# if [ -f /etc/bash_completion ]; then . /etc/bash_completion ; complete -cf sudo; fi



##################################################
# Alternative To The "200 Lines Kernel Patch That#
# Does Wonders" - not needed if have Linux kernel#
# 2.6.37 and higher				 #
##################################################

###### FOR DISTROS THAT USE '/cgroup/cpu' & '/etc/init.d/rc.local' (REDHAT/CENTOS?)
# Run sudo gedit /etc/init.d/rc.local & add following lines above "exit 0":
# 	mkdir -p /cgroup/cpu
# 	mount -t cgroup cgroup /cgroup/cpu -o cpu
# 	mkdir -m 0777 /cgroup/cpu/user
# 	echo "/usr/local/sbin/cgroup_clean" > /cgroup/cpu/release_agent
# Now, make it executable:
# sudo chmod +x /etc/init.d/rc.local
# To make sure that cgroups are deleted whenever the last task
# leaves, run sudo gedit /usr/local/sbin/cgroup_clean and copy-paste this:
# 	#!/bin/sh
# 	if [ "$*" != "/user" ]; then
# 	rmdir /cgroup/cpu/$*
# 	fi
# Now, make it executable:
# sudo chmod +x /usr/local/sbin/cgroup_clean
# Ensure the below ~/.bashrc section is uncommented
# Restart your computer to apply the changes.
#
#
#
# BEFORE YOU UNCOMMENT THE BELOW, MAKE SURE YOU'VE DONE THE ABOVE
#   if [ "$PS1" ] ; then
# 	mkdir -p -m 0700 /cgroup/cpu/user/$$ > /dev/null 2>&1
#       echo $$ > /cgroup/cpu/user/$$/tasks
#	echo "1" > /cgroup/cpu/user/$$/notify_on_release
#   fi



###### FOR DISTROS THAT USE '/sys/fs/cgroup/cpu' & '/etc/init.d/rc.local'
# Run sudo gedit /etc/init.d/rc.local & add following lines above "exit 0":
# 	mkdir -p /sys/fs/cgroup/cpu
# 	mount -t cgroup cgroup /sys/fs/cgroup/cpu -o cpu
# 	mkdir -m 0777 /sys/fs/cgroup/cpu/user
# 	echo "/usr/local/sbin/cgroup_clean" > /sys/fs/cgroup/cpu/release_agent
# Now, make it executable:
# sudo chmod +x /etc/init.d/rc.local
# To make sure that cgroups are deleted whenever the last task
# leaves, run sudo gedit /usr/local/sbin/cgroup_clean and copy-paste this:
# 	#!/bin/sh
# 	if [ "$*" != "/user" ]; then
# 	rmdir /sys/fs/cgroup/cpu/$*
# 	fi
# Now, make it executable:
# sudo chmod +x /usr/local/sbin/cgroup_clean
# Ensure the below ~/.bashrc section is uncommented
# Restart your computer to apply the changes.
#
#
#
# BEFORE YOU UNCOMMENT THE BELOW, MAKE SURE YOU'VE DONE THE ABOVE
#   if [ "$PS1" ] ; then
# 	mkdir -p -m 0700 /sys/fs/cgroup/cpu/user/$$ > /dev/null 2>&1
#       echo $$ > /sys/fs/cgroup/cpu/user/$$/tasks
#	echo "1" > /sys/fs/cgroup/cpu/user/$$/notify_on_release
#   fi



###### FOR UBUNTU (AND OTHER DISTROS THAT USE '/dev/cgroup/cpu' & '/etc/rc.local')
# Run sudo gedit /etc/rc.local & add following lines above "exit 0":
# 	mkdir -p /dev/cgroup/cpu
# 	mount -t cgroup cgroup /dev/cgroup/cpu -o cpu
# 	mkdir -m 0777 /dev/cgroup/cpu/user
# 	echo "/usr/local/sbin/cgroup_clean" > /dev/cgroup/cpu/release_agent
# Now, make it executable:
# sudo chmod +x /etc/rc.local
# To make sure that cgroups are deleted whenever the last task
# leaves, run sudo gedit /usr/local/sbin/cgroup_clean and copy-paste this:
# 	#!/bin/sh
# 	if [ "$*" != "/user" ]; then
# 	rmdir /dev/cgroup/cpu/$*
# 	fi
# Now, make it executable:
# sudo chmod +x /usr/local/sbin/cgroup_clean
# Ensure the below ~/.bashrc section is uncommented
# Restart your computer to apply the changes.
#
#
#
# BEFORE YOU UNCOMMENT THE BELOW, MAKE SURE YOU'VE DONE THE ABOVE
#    if [ "$PS1" ] ; then
# 	mkdir -p -m 0700 /dev/cgroup/cpu/user/$$ > /dev/null 2>&1
#   	echo $$ > /dev/cgroup/cpu/user/$$/tasks
#   	echo "1" > /dev/cgroup/cpu/user/$$/notify_on_release
#    fi



##################################################
# PATH						 #
##################################################

if [ "$UID" -eq 0 ]; then
    PATH=$PATH:/usr/local:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:~/Applications
fi

# remove duplicate path entries
export PATH=$(echo $PATH | awk -F: '
{ for (i = 1; i <= NF; i++) arr[$i]; }
END { for (i in arr) printf "%s:" , i; printf "\n"; } ')

# autocomplete ssh commands
#complete -W "$(echo `cat ~/.bash_history | egrep '^ssh ' | sort | uniq | sed 's/^ssh //'`;)" ssh
PYTHONPATH=$PYTHONPATHS:/usr/bin:/usr/lib/python2.7:/usr/lib/python2.7/plat-linux2:/usr/lib/python2.7/lib-tk:/usr/lib/python2.7/lib-old:/usr/lib/python2.7/lib-dynload:/usr/local/lib/python2.7/dist-packages:/usr/lib/python2.7/dist-packages:/usr/lib/python2.7/dist-packages/PIL:/usr/lib/python2.7/dist-packages/gst-0.10:/usr/lib/python2.7/dist-packages/gtk-2.0:/usr/lib/pymodules/python2.7:/usr/lib/python2.7/dist-packages/ubuntu-sso-client:/usr/lib/python2.7/dist-packages/ubuntuone-client:/usr/lib/python2.7/dist-packages/ubuntuone-installer:/usr/lib/python2.7/dist-packages/ubuntuone-storage-protocol:/usr/lib/python2.7/dist-packages/wx-2.8-gtk2-unicode:/usr/lib/python2.7/dist-packages/IPython/extensions:/home/vince/Projects/Dish/src/DishDB/


##################################################
# 'TIME' stuff...				 #
##################################################

###### Time redis ping in thousands of a second
# TIME=$( { time redis-cli PING; } 2>&1 ) ; echo $TIME | awk '{print $3}' | sed 's/0m//; s/\.//; s/s//; s/^0.[^[1-9]*//g;'



###### redirect bash built-in output to stdout
# TIME=$( { time YOUR_COMMAND_HERE; } 2>&1 ) ; echo $TIME



##################################################
# Startup programs				 #
##################################################

# if [ "$USE_SCREEN" = "Y" ]; then
#     if [ "$UID" -ne 0 ]; then
#         if [ "$SHLVL" -eq 1 ]; then
#             /usr/bin/screen -d -RR
#         fi
#     fi
# fi

# if [ -e "/usr/games/fortune" ]; then
#     echo "Fortune: "
#     /usr/games/fortune
#     echo
# fi

# if [ -e "/usr/bin/uptime" ]; then
#     echo "Uptime: ` /usr/bin/uptime`"
# fi
# echo
# ~/bin/rc_sync.sh
# $HOME/bin/motd.pl



##################################################
# Various options to make $HOME comfy		 #
##################################################

# if [ ! -d "${HOME}/bin" ]; then
#     mkdir ${HOME}/bin
#     chmod 700 ${HOME}/bin
#     echo "${HOME}/bin was missing.  I created it for you."
# fi

# if [ ! -d "${HOME}/Documents" ]; then
#     if ! [  -d "${HOME}/data" ]; then
#         mkdir ${HOME}/data
#         chmod 700 ${HOME}/data
#         echo "${HOME}/data was missing.  I created it for you."
#     fi
# fi

# if [ ! -d "${HOME}/tmp" ]; then
#     mkdir ${HOME}/tmp
#     chmod 700 ${HOME}/tmp
#     echo "${HOME}/tmp was missing.  I created it for you."
# fi



##################################################
# Stop Flash from tracking everything you do.	 #
##################################################

###### Brute force way to block all LSO cookies on Linux system with non-free Flash browser plugin
for A in ~/.adobe ~/.macromedia ; do ( [ -d $A ] && rm -rf $A ; ln -s -f /dev/null $A ) ; done



##################################################
# Bashrc greetings				 #
##################################################

###### greeting
# # from Jonathan's .bashrc file (by ~71KR117)
# # get current hour (24 clock format i.e. 0-23)
# hour=$(date +"%H")
# # if it is midnight to midafternoon will say G'morning
# if [ $hour -ge 0 -a $hour -lt 12 ]
# then
#   greet="Good Morning, $USER. Welcome back."
# # if it is midafternoon to evening ( before 6 pm) will say G'noon
# elif [ $hour -ge 12 -a $hour -lt 18 ]
# then
#   greet="Good Afternoon, $USER. Welcome back."
# else # it is good evening till midnight
#   greet="Good Evening, $USER. Welcome back."
# fi
# # display greeting
# echo $greet



###### holiday greeting
# # from Jonathan's .bashrc file (by ~71KR117)
# # get current day (Month-Day Format)
# day=$(date +"%B%e")
# # get current year (for new years greeting)
# year=$(date +"%Y")
# # make sure the holiday greeting is displayed (if any)
# hol=1
# # if it is New Year's Day
# if [ "$day" = "January1" ]
# then
#   holgreet="Happy New Years. Have a Happy $year."
# # if it is Groundhog Day
# elif [ "$day" = "February2" ]
# then
#   holgreet="Have a Happy Groundhog Day."
# # if it is Valentine's Day
# elif [ "$day" = "February14" ]
# then
#   holgreet="Have a Happy Valentine's Day."
# # if it is Independance Day
# elif [ "$day" = "July4" ]
# then
#   holgreet="Have a Happy Forth of July."
# # if it is my birthday
# elif [ "$day" = "July19" ]
# then
#   holgreet="Have a Happy Birthday."
# # if it is Halloween
# elif [ "$day" = "October31" ]
# then
#   holgreet="Happy Halloween."
# # if it is Christmas Eve
# elif [ "$day" = "December24" ]
# then
#   holgreet="Merry Christmas Eve."
# # if it is Christmas
# elif [ "$day" = "December25" ]
# then
#   holgreet="Merry Christmas."
# # if it is New Year's Eve
# elif [ "$day" = "December31" ]
# then
#   holgreet="Happy New Year's Eve."
# else
#   hol=0
# fi
# # display holiday greeting
# if [ "$hol" = "1" ]
# then
# echo $holgreet
# elif [ "$hol" = "0" ]
# then
#   randomvarthatsomehowimportant=0
# fi



##################################################
##################################################
##################################################








######################################################################################################################################################
###### COMPLETIONS ###### COMPLETIONS ###### COMPLETIONS ###### COMPLETIONS ###### COMPLETIONS ###### COMPLETIONS ###### COMPLETIONS ###### COMPLETIONS
######################################################################################################################################################








##################################################
# 'Universal' completion function		 #
##################################################

######  it works when commands have a so-called 'long options' mode
# ie: 'ls --all' instead of 'ls -a'
# Needs the '-o' option of grep
# (try the commented-out version if not available).
# First, remove '=' from completion word separators
# (this will allow completions like 'ls --color=auto' to work correctly).
COMP_WORDBREAKS=${COMP_WORDBREAKS/=/}



##################################################
# To enable tab-completion with sudo		 #
##################################################

###### alternatively, install bash-completion, which does this too
# complete -cf sudo



##################################################
# Completion functions (only since Bash-2.04)	 #
##################################################

###### avoid tilde expansion from the bash_completion script
function _expand()
{
    [ "$cur" != "${cur%\\}" ] && cur="$cur\\";
    if [[ "$cur" == \~*/* ]]; then
        #eval cur=$cur;
		:;
    else
        if [[ "$cur" == \~* ]]; then
            cur=${cur#\~};
            COMPREPLY=($( compgen -P '~' -u $cur ));
            return ${#COMPREPLY[@]};
        fi;
    fi
}



function _get_longopts()
{
    # $1 --help | sed  -e '/--/!d' -e 's/.*--\([^[:space:].,]*\).*/--\1/'| \
# grep ^"$2" |sort -u ;
    $1 --help | grep -o -e "--[^[:space:].,]*" | grep -e "$2" |sort -u
}



function _killall()
{
    local cur prev
    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}
    # get a list of processes (the first sed evaluation
    # takes care of swapped out processes, the second
    # takes care of getting the basename of the process)
    COMPREPLY=( $( /usr/bin/ps -u $USER -o comm  | \
        sed -e '1,1d' -e 's#[]\[]##g' -e 's#^.*/##'| \
        awk '{if ($0 ~ /^'$cur'/) print $0}' ))
    return 0
}
complete -F _killall killall killps



function _longopts()
{
    local cur
    cur=${COMP_WORDS[COMP_CWORD]}
    case "${cur:-*}" in
       -*)      ;;
        *)      return ;;
    esac
    case "$1" in
      \~*)      eval cmd="$1" ;;
        *)      cmd="$1" ;;
    esac
    COMPREPLY=( $(_get_longopts ${1} ${cur} ) )
}
complete  -o default -F _longopts configure bash
complete  -o default -F _longopts wget id info a2ps ls recode



function _make()
{
    local mdef makef makef_dir="." makef_inc gcmd cur prev i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in
        -*f)
            COMPREPLY=($(compgen -f $cur ));
            return 0
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($(_get_longopts $1 $cur ));
            return 0
        ;;
    esac;
    # make reads `GNUmakefile', then `makefile', then `Makefile'
    if [ -f ${makef_dir}/GNUmakefile ]; then
        makef=${makef_dir}/GNUmakefile
    elif [ -f ${makef_dir}/makefile ]; then
        makef=${makef_dir}/makefile
    elif [ -f ${makef_dir}/Makefile ]; then
        makef=${makef_dir}/Makefile
    else
        makef=${makef_dir}/*.mk        # Local convention.
    fi
    # Before we scan for targets, see if a Makefile name was
    # specified with -f ...
    for (( i=0; i < ${#COMP_WORDS[@]}; i++ )); do
        if [[ ${COMP_WORDS[i]} == -f ]]; then
           # eval for tilde expansion
           eval makef=${COMP_WORDS[i+1]}
           break
        fi
    done
    [ ! -f $makef ] && return 0
    # deal with included Makefiles
    makef_inc=$( grep -E '^-?include' $makef | \
    sed -e "s,^.* ,"$makef_dir"/," )
    for file in $makef_inc; do
        [ -f $file ] && makef="$makef $file"
    done
    # If we have a partial word to complete, restrict completions to
    # matches of that word.
    if [ -n "$cur" ]; then gcmd='grep "^$cur"' ; else gcmd=cat ; fi
    COMPREPLY=( $( awk -F':' '/^[a-zA-Z0-9][^$#\/\t=]*:([^=]|$)/ \
                                {split($1,A,/ /);for(i in A)print A[i]}' \
                                $makef 2>/dev/null | eval $gcmd  ))
}
complete -F _make -X '+($*|*.[cho])' make gmake pmake\



###### A meta-command completion function for commands like sudo(8), which need to
# first complete on a command, then complete according to that command's own
# completion definition - currently not quite foolproof,
# but still quite useful (By Ian McDonald, modified by me).
function _meta_comp()
{
    local cur func cline cspec
    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}
    cmdline=${COMP_WORDS[@]}
    if [ $COMP_CWORD = 1 ]; then
         COMPREPLY=( $( compgen -c $cur ) )
    else
        cmd=${COMP_WORDS[1]}            # Find command.
        cspec=$( complete -p ${cmd} )   # Find spec of that command.
        # COMP_CWORD and COMP_WORDS() are not read-only,
        # so we can set them before handing off to regular
        # completion routine:
        # Get current command line minus initial command,
        cline="${COMP_LINE#$1 }"
        # split current command line tokens into array,
        COMP_WORDS=( $cline )
        # set current token number to 1 less than now.
        COMP_CWORD=$(( $COMP_CWORD - 1 ))
        # If current arg is empty, add it to COMP_WORDS array
        # (otherwise that information will be lost).
        if [ -z $cur ]; then COMP_WORDS[COMP_CWORD]=""  ; fi
        if [ "${cspec%%-F *}" != "${cspec}" ]; then
      # if -F then get function:
            func=${cspec#*-F }
            func=${func%% *}
            eval $func $cline   # Evaluate it.
        else
            func=$( echo $cspec | sed -e 's/^complete//' -e 's/[^ ]*$//' )
            COMPREPLY=( $( eval compgen $func $cur ) )
        fi
    fi
}
complete -o default -F _meta_comp nohup \
eval exec trace truss strace sotruss gdb
complete -o default -F _meta_comp command type which man nice time



function _tar()
{
    local cur ext regex tar untar
    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}
    # If we want an option, return the possible long options.
    case "$cur" in
        -*)     COMPREPLY=( $(_get_longopts $1 $cur ) ); return 0;;
    esac
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=( $( compgen -W 'c t x u r d A' -- $cur ) )
        return 0
    fi
    case "${COMP_WORDS[1]}" in
        ?(-)c*f)
            COMPREPLY=( $( compgen -f $cur ) )
            return 0
            ;;
            +([^Izjy])f)
            ext='tar'
            regex=$ext
            ;;
        *z*f)
            ext='tar.gz'
            regex='t\(ar\.\)\(gz\|Z\)'
            ;;
        *[Ijy]*f)
            ext='t?(ar.)bz?(2)'
            regex='t\(ar\.\)bz2\?'
            ;;
        *)
            COMPREPLY=( $( compgen -f $cur ) )
            return 0
            ;;
    esac
    if [[ "$COMP_LINE" == tar*.$ext' '* ]]; then
        # Complete on files in tar file.
        #
        # Get name of tar file from command line.
        tar=$( echo "$COMP_LINE" | \
               sed -e 's|^.* \([^ ]*'$regex'\) .*$|\1|' )
        # Devise how to untar and list it.
        untar=t${COMP_WORDS[1]//[^Izjyf]/}
        COMPREPLY=( $( compgen -W "$( echo $( tar $untar $tar \
                    2>/dev/null ) )" -- "$cur" ) )
        return 0

    else
        # File completion on relevant files.
        COMPREPLY=( $( compgen -G $cur\*.$ext ) )
    fi
    return 0
}
complete -F _tar -o default tar



fi	# end interactive check﻿


